%{
#include <stdio.h>
#include "util.h"
#include "errormsg.h"
#include "symbol.h"
#include "table.h"
#include "absyn.h"

int yylex(void); /* function prototype */

void yyerror(char *s)
{
 EM_error(EM_tokPos, "%s", s);
}
%}


%union {
	int pos;
	int ival;
	string sval;
	S_symbol sym;
	A_var var;
	
	//函数实参(a,b)
	A_exp exp;
	A_expList explist;
	
	A_dec dec;
	A_decList declist;
	
	//定义记录的时候(a=exp,b=exp)
	A_efield	efield;
	A_efieldList efieldlist;
	
	//声明记录成员和函数形参的是后 (a:int ,b :string)
	A_field field;
	A_fieldList fieldlist;
	
	A_fundec fundec;
	A_fundecList funclist;
	
	A_ty ty;
	A_namety namety;
}

%token <sval> ID STRING
%token <ival> INT


%nonassoc ASSIGN ID 
%left  AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%right DO OF
%right UMINUS

%nonassoc LOWER_THAN_ELSE
%nonassoc ELSE
%nonassoc LBRACK
//%nonassoc 



%token 
  COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK 
  LBRACE RBRACE DOT 
  PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE
  AND OR ASSIGN
  ARRAY IF THEN ELSE WHILE FOR TO DO LET IN END OF 
  BREAK NIL
  FUNCTION VAR TYPE 

  /*非终结符类型*/
%type <exp> 		exp  stmt_exp array_create record_create cmp_exp math_exp bool_exp funcall_exp assign_stmt_exp if_stmt_exp let_stmt_exp  for_stmt_exp while_stmt_exp
//%type <sym> 		id
%type <efieldlist> 	record_fields  
%type <var> 		lvalue
%type <explist> 	explist expseq expseq_nonempty
%type <declist>   	decs  
%type <dec> 		dec  vardec fundec
%type <ty> 			ty
%type <fieldlist> 	tyfields
%type <namety> 		tydec
 
%start program

%%

program:	exp

exp:    lvalue								{$$=A_VarExp(EM_tokPos,$1);}
   |    stmt_exp 							{$$=$1;}
   |	array_create 						{$$=$1;}
   |	record_create 						{$$=$1;}
   |	cmp_exp 							{$$=$1;}
   |    math_exp 							{$$=$1;}
   |    bool_exp							{$$=$1;}
   |    INT									{$$ = A_IntExp(EM_tokPos, $1);}
   |	STRING								{$$ = A_StringExp(EM_tokPos,$1);}
   |	NIL									{$$ = A_NilExp(EM_tokPos);}
   |	expseq {/*(a;b;c)*/}
   |	BREAK								{$$=A_BreakExp(EM_tokPos);}

   
   
cmp_exp :   exp EQ exp						{ $$=A_OpExp(EM_tokPos,A_eqOp,$1,$3); }
		   | exp NEQ exp					{ $$=A_OpExp(EM_tokPos,A_neqOp,$1,$3); }
		   | exp GT exp						{ $$=A_OpExp(EM_tokPos,A_gtOp,$1,$3); }
		   | exp LT exp						{ $$=A_OpExp(EM_tokPos,A_ltOp,$1,$3); }
		   | exp GE exp						{ $$=A_OpExp(EM_tokPos,A_geOp,$1,$3); }
		   | exp LE exp						{ $$=A_OpExp(EM_tokPos,A_leOp,$1,$3); }

bool_exp:	exp AND exp						
			|exp OR exp
 
			   
math_exp:	exp PLUS exp 					{ $$=A_OpExp(EM_tokPos,A_plusOp,$1,$3); }
	   |    exp MINUS exp 					{ $$=A_OpExp(EM_tokPos,A_minusOp,$1,$3); }
	   |	exp TIMES exp					{ $$=A_OpExp(EM_tokPos,A_timesOp,$1,$3); }
	   |	exp DIVIDE exp					{ $$=A_OpExp(EM_tokPos,A_divideOp,$1,$3); }
	   |	MINUS exp %prec UMINUS 		   	{ $$ = A_OpExp(EM_tokPos, A_minusOp, A_IntExp(0,0) ,$2); /*0-exp*/}

  


//记录定义
//A_exp A_RecordExp(A_pos pos, S_symbol typ, A_efieldList fields);
record_create: ID LBRACE record_fields RBRACE {$$=A_RecordExp(EM_tokPos, S_Symbol($1), $3);}

//id1 = exp, id2=exp2
//A_efield A_Efield(S_symbol name, A_exp exp);
//A_efieldList A_EfieldList(A_efield head, A_efieldList tail);
record_fields: ID EQ exp					{$$ = A_EfieldList(A_Efield(S_Symbol($1), $3), NULL);}
			| ID EQ exp COMMA record_fields	{$$ = A_EfieldList(A_Efield(S_Symbol($1), $3), $5);}
			|								{$$=NULL;}

//与 lvalue 有已经规约冲突
//A_exp A_ArrayExp(A_pos pos, S_symbol typ, A_exp size, A_exp init);
//int [4+3] of 0
array_create: ID LBRACK exp RBRACK OF exp	{$$=A_ArrayExp(EM_tokPos,S_Symbol($1),$3,$6);}

lvalue: ID  		 						{$$=A_SimpleVar(EM_tokPos,S_Symbol($1)); }
		| lvalue DOT ID  					{$$=A_FieldVar(EM_tokPos,$1,S_Symbol($3));}/*a.b a[1].b*/
		| lvalue LBRACK exp RBRACK 			{$$=A_SubscriptVar(EM_tokPos,$1,$3);}/* a.b[2+3]  a[3+4]*/
		//id  		 						{$$=A_SimpleVar(EM_tokPos,$1); }
		//| id LBRACK exp RBRACK 				{$$ = A_SubscriptVar(EM_tokPos, A_SimpleVar(EM_tokPos, $1), $3);/*a[5+5]*/}
		
//id:     ID {  $$ = S_Symbol($1); }	  

	  
//各种语句
stmt_exp :  funcall_exp						
     |  assign_stmt_exp	 
     |  if_stmt_exp
	 |  let_stmt_exp
	 |  for_stmt_exp
	 |  while_stmt_exp

//函数调用
funcall_exp : ID LPAREN  explist RPAREN 	{ printf("funcall_exp\n" );}	 
	 
//赋值表达式	 
assign_stmt_exp : lvalue ASSIGN exp 		{ printf("assign stmt\n");}	

//if 语句
if_stmt_exp : IF exp THEN exp %prec LOWER_THAN_ELSE         { printf("if-then\n");}
			|  IF exp THEN exp ELSE exp 	{printf("if-then-else\n");}

//let 语句	 
/*
let decs in a=a+b;c=c+d end;
*/
let_stmt_exp: LET decs IN expseq END		{$$=A_LetExp(EM_tokPos,$2,A_SeqExp(EM_tokPos,$4));}		
	 
for_stmt_exp: FOR ID ASSIGN exp TO exp DO exp {$$=A_ForExp(EM_tokPos,S_Symbol($2),$4,$6,$8);}
	 
while_stmt_exp:WHILE exp DO exp    			{$$ = A_WhileExp(EM_tokPos,$2,$4);}
	 
//(exp1;exp2;exp3)
expseq: LPAREN expseq_nonempty RPAREN 		{ $$=$2;}
expseq_nonempty: exp						{$$ = A_ExpList($1,NULL); }
				| exp SEMICOLON expseq_nonempty	{ $$ = A_ExpList($1,$3); }
	 

//语句序列
// exp1,exp2
explist:exp 								{$$ = A_ExpList($1,NULL); }
		| exp COMMA explist					{$$ = A_ExpList($1,$3); }
		|									{$$=NULL;}

//声明语句块
decs: dec decs								{$$=A_DecList($1,$2);}			
	|										{$$=NULL;}

dec : tydec									{$$=$1;}
	| vardec 								{$$=$1; }
	| fundec								{$$=$1;}

//函数定义
fundec:	FUNCTION ID LPAREN tyfields RPAREN EQ exp { $$ =  A_Fundec(EM_tokPos,$2,$4,NULL,$7); }
	|	FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp {$$ = A_Fundec(EM_tokPos,$2,$4,$7,$9); }
	

	
//变量声明
vardec: VAR ID ASSIGN exp 					{ $$ = A_VarDec(EM_tokPos, S_Symbol($2), NULL, $4);}
		| VAR ID COLON ID ASSIGN exp		{$$ = A_VarDec(EM_tokPos, S_Symbol($2), S_Symbol($4), $6);}
	
//类型声明	
tydec: TYPE ID EQ ty						{$$ = A_Namety(S_Symbol($2), $4);}

ty:	ID										{$$ = A_NameTy(EM_tokPos, S_Symbol($1));}
	| LBRACE tyfields RBRACE				{$$ = A_RecordTy(EM_tokPos, $2);}
	| ARRAY OF ID 							{$$ = A_ArrayTy(EM_tokPos, S_Symbol($3));}
	
//id1 :int, id2 string
//A_field A_Field(A_pos pos, S_symbol name, S_symbol typ);
//A_fieldList A_FieldList(A_field head, A_fieldList tail);
tyfields :ID COLON ID						{$$ = A_FieldList(A_Field(EM_tokPos, S_Symbol($1), S_Symbol($3)), NULL);}
		|ID COLON ID COMMA tyfields			{$$ = A_FieldList(A_Field(EM_tokPos, S_Symbol($1), S_Symbol($3)), $5);}
		|									{$$=NULL;}
	 

	
